{"version":3,"sources":["js/imageloader.js"],"names":["imgInput","document","getElementById","resizeImage","canvas","newCanvas","newWidth","canvasContext","getContext","newCanvasContext","imageData","getImageData","width","height","console","log","oldWidth","oldHeight","blockWidth","Math","floor","newHeight","newData","ImageData","data","i","j","averageColor","x","y","pixel","getPixelColors","component","round","putImageData","grayscale","contrast","levels","coordR","length","avg","alpha","avgNonTransparent","coef","max","reduce","acc","val","idx","min","contr","mapArray","brickColor","forEach","el","addEventListener","e","target","files","imageFile","reader","FileReader","readAsDataURL","onloadend","myImage","Image","src","result","onload","ev","virtualCanvas","createElement","virtualContext","drawImage"],"mappings":";AAAA,MAAMA,EAAWC,SAASC,eAAe,cA0BzC,SAASC,EAAYC,EAAQC,EAAWC,GAChCC,MAAAA,EAAgBH,EAAOI,WAAW,MAClCC,EAAmBJ,EAAUG,WAAW,MAExCE,EAAYH,EAAcI,aAAa,EAAG,EAAGP,EAAOQ,MAAOR,EAAOS,QACxEC,QAAQC,IAAI,eAAgBL,GACtBM,MAAAA,EAAWN,EAAUE,MACrBK,EAAYP,EAAUG,OACtBK,EAAaC,KAAKC,MAAMJ,EAAWV,IAAa,EAChDe,EAAYF,KAAKC,MAAMH,EAAYC,GACzCJ,QAAQC,IAAI,iBAAkBG,GAC9BJ,QAAQC,IAAI,oBAAqBT,EAAU,IAAKe,GAE1CC,MAAAA,EAAU,IAAIC,UAAUjB,EAAUe,IAClC,KAAEG,GAASF,EACZ,IAAA,IAAIG,EAAI,EAAGA,EAAInB,EAAUmB,GAAK,EAC5B,IAAA,IAAIC,EAAI,EAAGA,EAAIL,EAAWK,GAAK,EAAG,CAC/BC,MAAAA,EAAe,CAAC,EAAG,EAAG,EAAG,GAC1B,IAAA,IAAIC,EAAIH,EAAIP,EAAYU,GAAKH,EAAI,GAAKP,EAAYU,GAAK,EACrD,IAAA,IAAIC,EAAIH,EAAIR,EAAYW,GAAKH,EAAI,GAAKR,EAAYW,GAAK,EAAG,CACvDC,MAAAA,EAAQC,EAAeH,EAAGC,EAAGnB,GAE/BsB,IAAAA,EAAY,EACTA,KAAAA,EAAY,GACjBL,EAAaK,IAAcF,EAAME,GAAad,GAAc,EAC5Dc,GAAa,EAIfA,IAAAA,EAAY,EACTA,KAAAA,EAAY,GACjBR,EAAS,EAAJC,EAAQC,EAAIpB,EAAW,EAAI0B,GAAab,KAAKc,MAAMN,EAAaK,IACrEA,GAAa,EAInBlB,QAAQC,IAAIO,GAEZjB,EAAUO,MAAmB,EAAXN,EAClBD,EAAUQ,OAAqB,EAAZQ,EACnBZ,EAAiByB,aAAaZ,EAAS,EAAG,GAC1Ca,EAAUX,GACVf,EAAiByB,aAAaZ,EAAShB,EAAU,GACjD8B,EAASZ,EAAM,KACff,EAAiByB,aAAaZ,EAAS,EAAGD,GAC1CgB,EAAOb,GACPf,EAAiByB,aAAaZ,EAAShB,EAAUe,GAGnD,SAASU,EAAeH,EAAGC,EAAGnB,GACtB4B,MAAAA,EAAST,GAAuB,EAAlBnB,EAAUE,OAAiB,EAAJgB,EAKpC,MAAA,CAJKlB,EAAUc,KAAKc,GACb5B,EAAUc,KAAKc,EAAS,GACzB5B,EAAUc,KAAKc,EAAS,GACvB5B,EAAUc,KAAKc,EAAS,IAIxC,SAASH,EAAUX,GACZ,IAAA,IAAIC,EAAI,EAAGA,EAAID,EAAKe,OAAQd,GAAK,EAAG,CACjCe,MAAAA,EAAMrB,KAAKc,OAAOT,EAAKC,GAAKD,EAAKC,EAAI,GAAKD,EAAKC,EAAI,IAAM,GACzDgB,EAAQjB,EAAKC,EAAI,GACjBiB,EAAqBF,EAAMC,EAAS,IAAM,IAAMA,EACtDjB,EAAKC,GAAKiB,EACVlB,EAAKC,EAAI,GAAKiB,EACdlB,EAAKC,EAAI,GAAKiB,EACdlB,EAAKC,EAAI,GAAK,KAIlB,SAASW,EAASZ,EAAMmB,EAAO,GACzBC,IAAAA,EAAMpB,EAAKqB,OAAO,CAACC,EAAKC,EAAKC,KAAUA,EAAM,GAAK,GAAKD,EAAMD,EAAMC,EAAaD,EAAM,GACtFG,EAAMzB,EAAKqB,OAAO,CAACC,EAAKC,EAAKC,KAAUA,EAAM,GAAK,GAAKD,EAAMD,EAAMC,EAAaD,EAAM,KAOtFG,GANJnC,QAAQC,IAAI,SAAUkC,EAAK,WAAYL,EAAK,YAAaD,GAGzDM,GAFAA,EAAM9B,KAAKc,MAAMgB,EAAMN,IAEX,GAAK,GAAKM,EACtBL,GAFAA,EAAMzB,KAAKc,MAAM,KAAO,IAAMW,GAAOD,IAEzB,IAAM,IAAMC,EACxB9B,QAAQC,IAAI,SAAUkC,EAAK,WAAYL,GACnCK,IAAQL,IAAgB,IAARK,GAAqB,MAARL,GAC5B,IAAA,IAAInB,EAAI,EAAGA,EAAID,EAAKe,OAAQd,GAAK,EAAG,CACjCe,MAAAA,GAAOhB,EAAKC,GAAKD,EAAKC,EAAI,GAAKD,EAAKC,EAAI,IAAM,EAChDyB,IAAAA,EAAQ/B,KAAKc,MAAqB,KAAOW,EAAMK,IAA3BT,EAAMS,IAC9BC,EAAQA,EAAQ,IAAM,IAAMA,EAC5B1B,EAAKC,GAAKyB,EACV1B,EAAKC,EAAI,GAAKyB,EACd1B,EAAKC,EAAI,GAAKyB,GAIlB,SAASb,EAAOb,EAAM2B,EAAW,CAAC,GAAI,IAAK,IAAK,MACzC,IAAA,IAAI1B,EAAI,EAAGA,EAAID,EAAKe,OAAQd,GAAK,EAAG,CACjCe,MAAAA,EAAMrB,KAAKc,OAAOT,EAAKC,GAAKD,EAAKC,EAAI,GAAKD,EAAKC,EAAI,IAAM,GAC3D2B,IAAAA,EAAa,EACjBD,EAASE,QAAQC,IACXd,GAAOc,EAAK,IAAMA,EAAKF,IAAYA,EAAaE,KAEtD9B,EAAKC,GAAK2B,EACV5B,EAAKC,EAAI,GAAK2B,EACd5B,EAAKC,EAAI,GAAK2B,GA5HlBpD,EAASuD,iBAAiB,SAAU,SAAUC,GACxCA,GAAAA,EAAEC,OAAOC,MAAO,CACdC,IAAAA,EAAYH,EAAEC,OAAOC,MAAM,GAC3BE,EAAS,IAAIC,WACjBD,EAAOE,cAAcH,GACrBC,EAAOG,UAAY,SAAUP,GACvBQ,IAAAA,EAAU,IAAIC,MAClBD,EAAQE,IAAMV,EAAEC,OAAOU,OACvBH,EAAQI,OAAS,SAAUC,GACrBC,IAAAA,EAAgBrE,SAASsE,cAAc,UACvCC,EAAiBF,EAAc9D,WAAW,MAC9C8D,EAAc1D,MAAQoD,EAAQpD,MAC9B0D,EAAczD,OAASmD,EAAQnD,OAC/B2D,EAAeC,UAAUT,EAAS,EAAG,GAMrC7D,EAAYmE,EAHGrE,SAASC,eAAe,YAGF","file":"imageloader.399c28ee.js","sourceRoot":"../src","sourcesContent":["const imgInput = document.getElementById('imageInput');\nimgInput.addEventListener('change', function (e) {\n  if (e.target.files) {\n    let imageFile = e.target.files[0]; //here we get the image file\n    let reader = new FileReader();\n    reader.readAsDataURL(imageFile);\n    reader.onloadend = function (e) {\n      let myImage = new Image(); // Creates image object\n      myImage.src = e.target.result; // Assigns converted image to image object\n      myImage.onload = function (ev) {\n        let virtualCanvas = document.createElement('canvas'); // Creates a canvas object\n        let virtualContext = virtualCanvas.getContext('2d'); // Creates a contect object\n        virtualCanvas.width = myImage.width; // Assigns image's width to canvas\n        virtualCanvas.height = myImage.height; // Assigns image's height to canvas\n        virtualContext.drawImage(myImage, 0, 0); // Draws the image on canvas\n        // let imgData = virtualCanvas.toDataURL('image/jpeg', 0.75); // Assigns image base64 string in jpeg format to a variable\n\n        let myCanvas = document.getElementById('myCanvas'); // Creates a canvas object\n        // let myContext = myCanvas.getContext('2d'); // Creates a contect object\n        // myContext.drawImage(newImage, 0, 0); // Draws the image on canvas\n        resizeImage(virtualCanvas, myCanvas, 90);\n      };\n    };\n  }\n});\n\nfunction resizeImage(canvas, newCanvas, newWidth) {\n  const canvasContext = canvas.getContext('2d');\n  const newCanvasContext = newCanvas.getContext('2d');\n  // 1. Count the amount of pixels in a block\n  const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n  console.log('imageData = ', imageData);\n  const oldWidth = imageData.width;\n  const oldHeight = imageData.height;\n  const blockWidth = Math.floor(oldWidth / newWidth) || 1;\n  const newHeight = Math.floor(oldHeight / blockWidth);\n  console.log('block width = ', blockWidth);\n  console.log('new dimensions = ', newWidth, 'x', newHeight);\n  // 2. Read block by coords\n  const newData = new ImageData(newWidth, newHeight);\n  const { data } = newData;\n  for (let i = 0; i < newWidth; i += 1) {\n    for (let j = 0; j < newHeight; j += 1) {\n      const averageColor = [0, 0, 0, 0];\n      for (let x = i * blockWidth; x < (i + 1) * blockWidth; x += 1) {\n        for (let y = j * blockWidth; y < (j + 1) * blockWidth; y += 1) {\n          const pixel = getPixelColors(x, y, imageData);\n          // 3. Count average color of block}\n          let component = 0;\n          while (component < 4) {\n            averageColor[component] += pixel[component] / blockWidth ** 2;\n            component += 1;\n          }\n        }\n      }\n      let component = 0;\n      while (component < 4) {\n        data[i * 4 + j * newWidth * 4 + component] = Math.round(averageColor[component]);\n        component += 1;\n      }\n    }\n  }\n  console.log(newData);\n  // 4. Draw image\n  newCanvas.width = newWidth * 2;\n  newCanvas.height = newHeight * 2;\n  newCanvasContext.putImageData(newData, 0, 0);\n  grayscale(data);\n  newCanvasContext.putImageData(newData, newWidth, 0);\n  contrast(data, 2.5);\n  newCanvasContext.putImageData(newData, 0, newHeight);\n  levels(data);\n  newCanvasContext.putImageData(newData, newWidth, newHeight);\n}\n\nfunction getPixelColors(x, y, imageData) {\n  const coordR = y * (imageData.width * 4) + x * 4;\n  const red = imageData.data[coordR];\n  const green = imageData.data[coordR + 1];\n  const blue = imageData.data[coordR + 2];\n  const alpha = imageData.data[coordR + 3];\n  return [red, green, blue, alpha];\n}\n\nfunction grayscale(data) {\n  for (let i = 0; i < data.length; i += 4) {\n    const avg = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);\n    const alpha = data[i + 3];\n    const avgNonTransparent = (avg * alpha) / 255 + 255 - alpha;\n    data[i] = avgNonTransparent; // red\n    data[i + 1] = avgNonTransparent; // green\n    data[i + 2] = avgNonTransparent; // blue\n    data[i + 3] = 255; // alpha\n  }\n}\n\nfunction contrast(data, coef = 1) {\n  let max = data.reduce((acc, val, idx) => ((idx + 1) % 4 ? (val > acc ? val : acc) : acc), 0);\n  let min = data.reduce((acc, val, idx) => ((idx + 1) % 4 ? (val < acc ? val : acc) : acc), 255);\n  console.log('min = ', min, ', max = ', max, ', coef = ', coef);\n  min = Math.round(min * coef);\n  max = Math.round(255 - (255 - max) * coef);\n  min = min > 47 ? 47 : min;\n  max = max < 160 ? 160 : max;\n  console.log('min = ', min, ', max = ', max);\n  if (min === max || (min === 0 && max === 255)) return;\n  for (let i = 0; i < data.length; i += 4) {\n    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n    let contr = Math.round((avg - min) * (255 / (max - min)));\n    contr = contr > 255 ? 255 : contr;\n    data[i] = contr; // red\n    data[i + 1] = contr; // green\n    data[i + 2] = contr; // blue\n  }\n}\n\nfunction levels(data, mapArray = [63, 127, 191, 255]) {\n  for (let i = 0; i < data.length; i += 4) {\n    const avg = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);\n    let brickColor = 0;\n    mapArray.forEach(el => {\n      if (avg >= el - 16 && el > brickColor) brickColor = el;\n    });\n    data[i] = brickColor; // red\n    data[i + 1] = brickColor; // green\n    data[i + 2] = brickColor; // blue\n  }\n}\n"]}